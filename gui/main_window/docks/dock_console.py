# -*- coding: utf-8 -*-
import traceback

import PyQt5.QtGui as QtGui
from PyQt5.Qt import QTextCursor
from PyQt5.QtWidgets import QWidget, QTextEdit, QLabel, QComboBox, QVBoxLayout, QHBoxLayout

from backend.barista.utils.logger import Log, Logger
from gui.main_window.docks.dock import DockElement


class DockElementConsole(DockElement):

    def __init__(self, mainWindow, title):
        DockElement.__init__(self, mainWindow, 'Console')
        self.name = title
        self.resize(700, 500)
        self.widget = QWidget()

        Log.newLine.connect(self.appendLineToConsole)
        Log.sigRefreshGui.connect(self.appendLinesToConsole)
        Log.sigRefreshCallers.connect(self.fillCallerComboBox)

        self.__callersCopy = []

        self.__currentCallerFilter = -1
        self.__currentTypeFilter = -1

        self.__msgTypes = [Logger.ALL, Logger.ERROR, Logger.TEXT]

        self.__logOutput = None
        self.__callerComboBox = None

        self.__scrollDown = True

        self.__setupGui()

    def clearLog(self):
        '''
        clears all input in the edittext field
        '''
        self.__logOutput.clear()

    def appendLineToConsole(self, logline):
        '''
        adds a line of input the the console
        with prefix if it is not filtered
        '''
        if(self.__shouldDisplayLogLine(logline)):

            try:
                self.__setupFont(logline.caller, logline.msgType)

                sb = self.__logOutput.verticalScrollBar()
                if sb.value() >= sb.maximum():
                    self.__scrollDown = True
                else:
                    self.__scrollDown = False

                # self.__writePrefix(logline.caller) not used because there is no append..
                logText = logline.line
                self.__logOutput.append(self.__getPrefix(logline.caller, logline.time) + logText)
            except:
                errMsg = traceback.format_exc()
                self.__logOutput.append("Error during printing a log line: {}".format(
                    errMsg
                ))

    def __writePrefix(self, caller):
        '''
        NOT USED because of no appen of plain text
        and self.__setCursorToEnd() leads to lag of gui

        writes the prefix to the log
        without line feed
        '''
        font = self.__logOutput.font()
        font.setBold(True)
        self.__logOutput.setCurrentFont(font)

        self.__logOutput.insertPlainText(self.__getPrefix(caller))

        font = self.__logOutput.font()
        font.setBold(False)
        self.__logOutput.setCurrentFont(font)

    def __getPrefix(self, caller, time):
        '''
        the prefix that have to be added
        '''
        prefix = ""
        if self.__currentCallerFilter == -1:
            prefix = "[" + time + ", " + caller.description + "]"
        return prefix

    def __shouldDisplayLogLine(self, logline):
        '''
        returns whether this line should be displayed. Filtered on Caller
        and MessageType
        '''
        if(self.__currentCallerFilter == -1):
            if(self.__currentTypeFilter != -1):
                return (logline.msgType.typeId == self.__currentTypeFilter)
            return True
        elif(logline.caller.callerId == self.__callersCopy[self.__currentCallerFilter].callerId):
            if(self.__currentTypeFilter == -1):
                return True
            else:
                return logline.msgType.typeId == self.__currentTypeFilter
        return False

    def appendLinesToConsole(self, loglines):
        '''
        adds multiple lines to the console
        '''
        for logline in loglines:
            self.appendLineToConsole(logline)

    def __setupFont(self, caller, msgType):
        '''
        setup the font
        '''
        font = self.__logOutput.font()
        font.setBold(False)
        color = caller.color

        if(msgType == Logger.ERROR):
            color = msgType.color

        font.setFamily("Courier")
        font.setPointSize(10)
        self.__logOutput.setCurrentFont(font)
        self.__logOutput.setTextColor(color)

    def __setupGui(self):
        '''
        adds the wigets to the gui
        '''
        self.__logOutput = QTextEdit(self.widget)
        self.__logOutput.setReadOnly(True)
        self.__logOutput.setLineWrapMode(QTextEdit.NoWrap)
        self.__logOutput.verticalScrollBar().rangeChanged.connect(self.handleSroll)

        labelCallers = QLabel("Show output generated by ")
        self.__callerComboBox = QComboBox()
        self.__callerComboBox.currentIndexChanged.connect(self.__filterCallers)
        labelTypes = QLabel("Show messages of type ")
        self.__typeComboBox = QComboBox()
        self.__typeComboBox.currentIndexChanged.connect(self.__filterTypes)

        for type in self.__msgTypes:
            self.__typeComboBox.addItem(type.description)
        Log.refreshCallers()

        vbox = QVBoxLayout()

        hbox = QHBoxLayout()
        hbox.addWidget(labelCallers)
        hbox.addWidget(self.__callerComboBox)
        hbox.addWidget(labelTypes)
        hbox.addWidget(self.__typeComboBox)
        hbox.addStretch(1)

        vbox.addLayout(hbox)

        vbox.addWidget(self.__logOutput)

        self.widget.setLayout(vbox)
        self.widget.resize(700, 500)
        self.setWidget(self.widget)

    def __setCursorToEnd(self):
        '''
        used to not insert new lines at the users
        selection
        '''
        self.__logOutput.moveCursor(QTextCursor.End)

    def fillCallerComboBox(self, callers):
        '''
        inserts the data for the filter caller combo box
        callers is a dictionary callerid (int) -> Caller object
        '''
        #Display only callers that have content logged
        filterCallers = lambda caller: caller.used == True
        #save copy to get right index
        self.__callersCopy = list(filter(filterCallers, callers.values()))

        self.__callerComboBox.clear()
        model = self.__callerComboBox.model()
        # Appen All
        item = QtGui.QStandardItem(str(Logger.ALL.description))  # no Error
        model.appendRow(item)
        # AppendCallers
        for caller in self.__callersCopy :
            item = QtGui.QStandardItem(str(caller.description))
            item.setForeground(caller.color)
            model.appendRow(item)

    def handleSroll(self):
        '''
        cares about whether the scrollbar has to be on bottom of
        the console or not
        '''
        sb = self.__logOutput.verticalScrollBar()
        if(self.__scrollDown):
            sb.setValue(sb.maximum())

    def __filterCallers(self, i):
        if(i == -1):
            return; # invalid filter, empty box or resetet
        self.__currentCallerFilter = i-1    # -1 Because of "ALL"
        self.clearLog()
        Log.refreshConsole()

    def __filterTypes(self, i):
        self.__currentTypeFilter = i-1  # -1 Because of "ALL"
        self.clearLog()
        Log.refreshConsole()
